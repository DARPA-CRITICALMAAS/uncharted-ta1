from unittest import result
from PIL import Image
import numpy as np
from tqdm import tqdm
from typing import List

from common.task import Task, TaskInput, TaskResult

from tasks.point_extraction.entities import MapTile, MapTiles, MapImage, MapPointLabel


class Tiler(Task):
    # TODO: handle case where image already has labels attached to it.
    def __init__(self, task_id="", tile_size=(512, 512), overlap=0.25):
        self.tile_size = tile_size
        self.overlap = overlap
        super().__init__(task_id)

    def run(
        self,
        task_input: TaskInput,
    ) -> TaskResult:
        image_array = np.array(task_input.image)
        original_height, original_width, _ = image_array.shape

        step_x = int(self.tile_size[0] * (1 - self.overlap))
        step_y = int(self.tile_size[1] * (1 - self.overlap))

        tiles: List[MapTile] = []

        for y in range(0, original_height, step_y):
            for x in range(0, original_width, step_x):
                width = min(self.tile_size[0], original_width - x)
                height = min(self.tile_size[1], original_height - y)

                tile_array = image_array[y : y + height, x : x + width]

                if (
                    tile_array.shape[0] < self.tile_size[1]
                    or tile_array.shape[1] < self.tile_size[0]
                ):
                    padded_tile = np.zeros(
                        (self.tile_size[1], self.tile_size[0], 3),
                        dtype=tile_array.dtype,
                    )

                    padded_tile[:height, :width] = tile_array
                    tile_array = padded_tile

                maptile = MapTile(
                    x_offset=x,
                    y_offset=y,
                    width=self.tile_size[0],
                    height=self.tile_size[1],
                    image=Image.fromarray(tile_array),
                    map_path="",
                )
                tiles.append(maptile)
        map_tiles = MapTiles(raster_id=task_input.raster_id, tiles=tiles)
        return TaskResult(
            task_id=self._task_id, output={"map_tiles": map_tiles.model_dump()}
        )

    @property
    def input_type(self):
        return MapImage

    @property
    def output_type(self):
        return List[MapTile]


class Untiler(Task):
    def __init__(self, task_id=""):
        super().__init__(task_id)

    """
    Used to reconstruct the original image from the tiles and map back the bounding boxes and labels.
    Note that new images aren't actually constructed here, we are just mapping predictions from tiles onto the original map.
    """

    def run(self, input: TaskInput) -> TaskResult:
        """
        Reconstructs the original image from the tiles and maps back the bounding boxes and labels.
        tile_predictions: List of MapPointLabel objects. Generated by the model. TILES MUST BE FROM ONLY ONE MAP.
        returns: List of MapPointLabel objects. These can be mapped directly onto the original map.
        """

        map_tiles = MapTiles.model_validate(input.get_data("map_tiles"))
        tiles = map_tiles.tiles

        assert all(
            i.predictions is not None for i in tiles
        ), "Tiles must have predictions attached to them."
        all_predictions = []
        map_path = tiles[0].map_path
        for tile in tiles:
            for pred in tqdm(
                tile.predictions,
                desc="Reconstructing original map with predictions on tiles",
            ):
                x_offset = tile.x_offset  # xmin of tile, absolute value in original map
                y_offset = tile.y_offset  # ymin of tile, absolute value in original map

                x1 = pred.x1
                x2 = pred.x2
                y1 = pred.y1
                y2 = pred.y2
                score = pred.score
                label_name = pred.class_name

                global_prediction = MapPointLabel(
                    classifier_name=pred.classifier_name,
                    classifier_version=pred.classifier_version,
                    class_id=pred.class_id,
                    class_name=label_name,
                    x1=x1
                    + x_offset,  # Add offset of tile to project onto original map.
                    y1=y1 + y_offset,
                    x2=x2 + x_offset,
                    y2=y2 + y_offset,
                    score=score,
                    directionality=pred.directionality,
                )

                all_predictions.append(global_prediction)
        map_image = MapImage(path=map_path, labels=all_predictions)
        return TaskResult(task_id=self._task_id, output={"map_image": map_image})

    @property
    def input_type(self):
        return List[MapTile]

    @property
    def output_type(self):
        return MapImage
